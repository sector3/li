#!/Users/user/pkg/bin/lua5.2

curses = require 'curses'

if (#arg ~= 1) then
    io.write('usage: li [file]\n')
    os.exit()
end

fileTable = { charCount = 0, lineCount = 0, curLoc = 0 }
-- check arg[1] for filename, try open, else create
f = io.open(arg[1], 'r')       -- existing file
if ( f == nil ) then
    f = io.open(arg[1], 'w')    -- new file
else
    -- gather stats on existing file
    fileTable.charCount = f:seek('end')
    f:seek('set', 0)
    for l in f:lines() do fileTable.lineCount = fileTable.lineCount + 1 end
    f:seek('set', 0)
    fileTable = { charCount = filesize, lineCount = lcount }
end

-- init screen and get some info
curses.initscr()
curses.cbreak()
curses.echo(false)
curses.nl(false)
stdscr = curses.stdscr()
stdscr:clear()
Y, X = stdscr:getmaxyx()
screen = { x = X, y = Y }

function fileLines (f)     -- iterator factory: while there are lines in a
-- 1st iteration i is 0    -- file, return them
    local i = -1
    return function () i = i + 1; return f:read('*l'), i end
end

-- print and repl
if fileTable.charCount == 0 then
    for i = 1,screen.x do stdscr:mvaddstr(i,0,'~') end
    stdscr:move(0,0)
else
    if fileTable.charCount ~= 0 then
        for l, i in fileLines(f) do
            stdscr:mvaddstr(i,0,l)
        end
    end
end
stdscr:refresh()
c = stdscr:getch() ; if c < 256 then c = string.char(c) end
while (c ~= 'q') do
    c = stdscr:getch() ; if c < 256 then c = string.char(c) end
end
stdscr:refresh()


-- print info and quit
curses.endwin()
print('x:', screen.x)
print('y:', screen.y)
if (fileTable ~= nil ) then
    print('chars', fileTable.charCount)
    print('lines', fileTable.lineCount)
end

fileLen = f:seek('end')
io.close(f)
if (fileLen == 0 ) then os.remove(arg[1]) end
