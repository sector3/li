#!/Users/user/pkg/bin/lua5.2

curses = require 'curses'

if (#arg ~= 1) then
    io.write('usage: li [file]\n')
    os.exit()
end

fileTable = { charCount = 0, lineCount = 0, curLoc = 0 }
-- check arg[1] for filename, try open, else create
f = io.open(arg[1], 'r')       -- existing file
if ( f == nil ) then
    fbuf = ''                  -- don't need file yet, just buffer will do
else
    -- gather stats on existing file
    fbuf = f:read('*a')
    --io.close(f)
    fileTable.charCount = f:seek('end')
    f:seek('set', 0)
    for l in f:lines() do fileTable.lineCount = fileTable.lineCount + 1 end
    f:seek('set', 0)
    fileTable = { charCount = filesize, lineCount = lcount }
end

-- init screen and get some info
curses.initscr()
curses.cbreak()
curses.echo(false)
curses.nl(false)
stdscr = curses.stdscr()
stdscr:clear()
Y, X = stdscr:getmaxyx()
screen = { x = X, y = Y }

function fileLines (f)     -- iterator factory: while there are lines in a
-- 1st iteration i is 0    -- file, return them
    local i = -1
    return function () i = i + 1; return f:read('*l'), i end
end

-- print file if exists
if fileTable.charCount == 0 then
    for i = 1,screen.x do stdscr:mvaddstr(i,0,'~') end
else
    for l, i in fileLines(f) do
        stdscr:mvaddstr(i,0,l)
        for j = i+1,screen.x do stdscr:mvaddstr(j,0,'~') end
    end
end
stdscr:move(0,0)
stdscr:refresh()

-- input mode
repeat            -- if character is printable
c = stdscr:getch() ; if c < 256 then c = string.char(c) end
until (     c == 'q'       -- Unsure how to do this. There are a lot of cmds
         or c == 'q'    )  -- in vi. List could be inclusive or exclusive.

stdscr:refresh()

-- print info and quit
curses.endwin()
